{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf360
{\fonttbl\f0\froman\fcharset0 Times-Roman;\f1\fnil\fcharset0 LucidaGrande;}
{\colortbl;\red255\green255\blue255;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\paperw11900\paperh16840\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\deftab720
\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
\ls1\ilvl0
\f0\fs24 \cf0 {\listtext	\'95	}Finish writing code for all of the functions that we did not finish in class\
{\listtext	\'95	}\
{\listtext	\'95	}add a third variable to the data structure in data.h. This variable will of type char and be named numeral\
{\listtext	\'95	}Given the function definition struct data* createDataNumeral(char num). This function will allocate space for a data structure and set the new variable numeral in the data struct equal to the input variable num. This function will be added to the data.h and data.c files.\
{\listtext	\'95	}Given the function int convertRomanNumeralStack(struct stack *s). This function will calculate the value of the roman numeral that is on the stack and return it. However, unlike traditional roman numerals, we can have negative numbers. A negative number is produced when the roman numerals are ordered from smallest to largest. When the numerals are not ordered from smallest to largest, the number is calculated as a traditional roman numeral. The numerals are read from left to right. This is the same order, from left to right, that the numbers should be pushed on to the stack. Print the returned value from this function followed by a newline 
\f1 \uc0\u8232 
\f0 Examples:
\f1 \uc0\u8232 
\f0 VII would print 
\f1 \uc0\u8232 
\f0 7
\f1 \uc0\u8232 
\f0 IIIIIIIV would print
\f1 \uc0\u8232 
\f0 -2
\f1 \uc0\u8232 
\f0 MCMXCIX would print
\f1 \uc0\u8232 
\f0 1999
\f1 \uc0\u8232 
\f0 IIIVVVX would print
\f1 \uc0\u8232 
\f0 -8\
{\listtext	\'95	}Given the function int convertRomanNumeralQueue(struct queue *q). The function will calculate the value of the roman numeral that is on the queue and return it. However, unlike traditional roman numerals, we can have negative numbers. A negative number is produced when the roman numerals are ordered from smallest to largest. When the numerals are not ordered from smallest to largest, the number is calculated as a traditional roman numeral. The numerals are read from left to right. This is the same order, from left to right, that the numbers should be pushed on to the queue. The value returned from this function should match the values that are returned from the getRomanNumeralStackFunction. Print the returned value from this function followed by a newline \
{\listtext	\'95	}Modify you main function so that it takes in command line arguments. The command line arguments will be the executable followed by the roman numeral you wish to convert. 
\f1 \uc0\u8232 
\f0 ex: ./main XXVI
\f1 \uc0\u8232 
\f0 All roman numerals entered will be in uppercase.
\f1 \uc0\u8232 
\f0 Each letter of the roman numeral you wish to convert should be pushed onto both a stack and a queue, then call both the stack and queue versions of the convertRomanNumeral functions. Finally, print the returned values from those functions
\f1 \uc0\u8232 
\f0 You will need to create both a stack and a queue in the main.c file. So you will have to take the queue and stack files and place them in the same directory. You may also need to change you make file for this.\
\pard\pardeftab720\ql\qnatural
\cf0 \
}
